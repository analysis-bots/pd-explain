from typing import Literal

from .explainer_interface import ExplainerInterface
import pandas as pd
from pandas import DataFrame, Series
from warnings import warn
from cluster_explorer import Explainer, condition_generator, str_rule_to_list, rule_to_human_readable
from sklearn.decomposition import PCA
from matplotlib import pyplot as plt
import numpy as np
from ipywidgets import Tab, HTML, HTMLMath, Output, VBox, HBox, Box, Layout
from IPython.display import display


class ManyToOneExplainer(ExplainerInterface):

    def __init__(self, source_df: DataFrame, labels: Series | str | list[int], coverage_threshold: float = 0.6,
                 max_explanation_length: int = 5, separation_threshold: float = 0.5, p_value: int = 0,
                 use_pca_for_visualization: bool = True, pca_components: Literal[2, 3] = 2):

        self._source_df = source_df

        if isinstance(labels, str):
            self._labels = source_df[labels]
        elif not isinstance(labels, Series):
            self._labels = Series(labels)
        else:
            self._labels = labels

        self._possible_to_visualize = True

        if p_value < 0:
            raise ValueError("The p-value must be a positive number.")
        if coverage_threshold < 0 or coverage_threshold > 1:
            raise ValueError("The coverage threshold must be between 0 and 1.")
        if max_explanation_length < 1:
            raise ValueError("The maximum explanation length must be at least 1.")
        if separation_threshold < 0 or separation_threshold > 1:
            raise ValueError("The separation threshold must be between 0 and 1.")
        if use_pca_for_visualization and pca_components > 3:
            raise ValueError("The number of PCA components must be at most 3. We do not support 4D or higher plots.")
        if not use_pca_for_visualization and source_df.shape[1] > 3:
            warn("The dataframe is too high dimensional to visualize. We recommend using PCA for visualization.")
            self._possible_to_visualize = False

        self._coverage_threshold = coverage_threshold
        self._max_explanation_length = max_explanation_length
        self._separation_threshold = separation_threshold
        self._conciseness_threshold = 1 / self._max_explanation_length

        if p_value == 0:
            p_value = max_explanation_length

        self._p_value = p_value

        self._use_pca_for_visualization = use_pca_for_visualization
        self._pca_components = pca_components
        self._explanations = None

    def can_visualize(self) -> bool:
        return self._possible_to_visualize

    def _plot_clusters(self, to_visualize: np.ndarray, cluster_labels: np.ndarray | Series):
        """
        Visualizes all clusters in the data each in a different color, in one plot.
        """
        # Create a 3D plot if the data is 3D, otherwise create a 2D plot.
        if to_visualize.shape[1] == 3:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
        else:
            fig, ax = plt.subplots()

        labels = cluster_labels.unique()
        labels.sort()

        for i, label in enumerate(labels):
            try:
                label_title = f"Cluster {int(label)}"
            except ValueError:
                label_title = f"{label}"
            current_datapoints = to_visualize[cluster_labels == label]
            if to_visualize.shape[1] == 3:
                ax.scatter(current_datapoints[:, 0], current_datapoints[:, 1], current_datapoints[:, 2],
                           label=label_title)
            else:
                ax.scatter(current_datapoints[:, 0], current_datapoints[:, 1], label=label_title)

        return fig, ax

    def _convert_rules(self, rules: DataFrame) -> DataFrame:
        """
        Converts the rules from the explainer into forms that are more suitable to work with in code and for visualization.

        :param rules: The rules generated by the explainer.
        :return: The converted rules.
        """
        converted_rules = DataFrame(columns=['Rule', 'Cluster', 'Explanation', 'Idx', 'Human Readable Rule'])
        for explanation in rules.iterrows():
            # The explanation is a tuple, where the first element is the index and the second element is the explanation.
            idx = explanation[0]
            explanation = explanation[1]
            # We first convert the stringified rule to a list of conditions, create a binary array from the rule,
            # and finally we also convert it into a human readable format, then save everything.
            rule = str_rule_to_list(explanation['rule'])
            rule_as_binary_np_array = condition_generator(data=self._source_df, rules=[rule])
            human_readable_rule = rule_to_human_readable(rule)
            cluster = explanation['Cluster']
            converted_rules = pd.concat(
                [converted_rules, DataFrame({'Rule': [rule_as_binary_np_array], 'Cluster': cluster,
                                             'Explanation': explanation['rule'], 'Idx': idx,
                                             'Human Readable Rule': human_readable_rule})])
        return converted_rules

    def _create_general_tab(self, to_visualize: np.ndarray, cluster_labels: np.ndarray | Series) -> Tab:
        """
        Creates the initial tab of the visualizations, that contains:</br>
        1. A plot of all clusters in the data, each in a different color.</br>
        2. An explanation of the quality metrics used to evaluate the explanations.

        :param to_visualize: The data to visualize.
        :param cluster_labels: The labels of the clusters.
        :return: The tab containing the visualizations.
        """
        out = Output()
        with out:
            fig, ax = self._plot_clusters(to_visualize, cluster_labels)
            ax.legend(loc='upper right')
            plt.show(fig)

        general_tab = Tab()
        metric_explanations_html = HTMLMath(f"""
                    <h2>Explanation quality metrics</h2>
                    <h4>Conciseness</h4>
                    <p>Conciseness is a measure of how concise the explanation is. It is calculated as the inverse of the number of 
                    conditions in the rule.
                    A rule with fewer conditions is considered more concise and thus better.
                    </p>
                    <h4>Separation error</h4>
                    <p>The ratio of points for which explanation $E_c$ holds, but those points are not in cluster / group $c$. 
                    Mathematically, it is defined as: $$\\frac{{|\\ x \\in X \\ | \\ E_c (x) = True \wedge CL(x) \\neq c \\ |}}{{|\\ x \\in X \\ | \\ E_c(x) = True\\ |}}$$
                    The lower the separation error, the better the explanation is at separating the cluster from other points.
                    </p>
                    <h4>Coverage</h4>
                    <p>The ratio of points for which explanation $E_c$ holds and those points are in cluster / group $c$.
                    Mathematically, it is defined as: $$\\frac{{|\\ x \\in X \\ | \\ E_c (x) = True \wedge CL(x) = c\\ |}}{{|\\ x \\in X \\ | \\ CL(x) = c \\ |}}$$
                    The higher the coverage, the better.
                    </p>
                """)
        general_tab.children = [Box(children=[out]), metric_explanations_html]
        general_tab.set_title(0, "All Clusters Plot")
        general_tab.set_title(1, "Explanation Metrics")

        return general_tab

    def _create_tab_for_cluster(self, cluster: str | int, rules: DataFrame, to_visualize: np.ndarray,
                                cluster_title: str, ) -> Tab:
        """

        """
        cluster_tab = Tab()
        cluster_explanations = self._explanations[self._explanations['Cluster'] == cluster]
        cluster_rules = rules[rules['Cluster'] == cluster]
        cluster_outputs = []

        if cluster_explanations.empty:
            res = HTML(f"<h2>No explanation found for {cluster_title}</h2>")
            return res

        # Go over the rules for each cluster, and plot the data, emphasizing the data points that are explained by
        # each rule. Each of these plots go into a separate sub-tab.
        for rule in cluster_rules.iterrows():
            tab_hbox = HBox()
            text_vbox = VBox(layout=Layout(width='30%'))
            rule_row = rule[1]
            idx = rule_row['Idx']
            rule = rule_row['Rule']
            explanation_row = self._explanations.iloc[idx]

            # Get the data points that are explained by the rule.
            explained_data_points = to_visualize[rule]

            out = Output()

            # Visualize all the data, then add an "X" marker for the data points that are explained by the rule.
            with out:
                fig, ax = self._plot_clusters(to_visualize, self._labels)
                ax.scatter(explained_data_points[:, 0], explained_data_points[:, 1], marker='X', c='black',
                           label='Covered by rule')
                # Add a legend with cluster labels + "X" for the explained data points.
                ax.legend(loc='upper right')
                plt.show(fig)

            text_vbox.children = [HTML(f"""
                        <h4>Rule:<br> {rule_row['Human Readable Rule']}</h4><hr width='100%' size='2'>
                        <h5>Conciseness: {explanation_row['conciseness']}</h5><br>
                        <h5>Separation error: {explanation_row['separation_err']}</h5><br>
                        <h5>Coverage: {explanation_row['coverage']}</h5><br>
                        """, tooltip="Test")]
            left_box = Box(children=[out], layout=Layout(width='70%'))
            tab_hbox.children = [left_box, text_vbox]

            cluster_outputs.append(tab_hbox)

        # Add the explanations to the tab.
        cluster_tab.children = cluster_outputs
        for i, output in enumerate(cluster_outputs):
            cluster_tab.set_title(i, f"Explanation {i + 1}")

        return cluster_tab

    def visualize(self):
        # Since most dataframes are too high dimensional to visualize, we use PCA to reduce the dimensionality.
        # The user can choose to use PCA for visualization or not.
        if self._use_pca_for_visualization:
            pca = PCA(n_components=self._pca_components)
            to_visualize = pca.fit_transform(self._source_df)
        else:
            to_visualize = self._source_df

        converted_rules = self._convert_rules(self._explanations)

        cluster_titles = []
        unique_cluster_labels = self._labels.unique()
        # Get a list of cluster titles, which will be used as the titles of the tabs.
        # The title is either "Cluster {cluster_id}" if the cluster id is an int or the name of the cluster.
        for cluster in unique_cluster_labels:
            try:
                cluster_titles.append(f"Cluster {int(cluster)}")
            except ValueError:
                cluster_titles.append(f"{cluster}")

        cluster_tabs = Tab()
        cluster_tabs_children = [self._create_general_tab(to_visualize, self._labels)]

        for i, cluster in enumerate(unique_cluster_labels):
            cluster_tabs_children.append(
                self._create_tab_for_cluster(cluster, converted_rules, to_visualize, cluster_titles[i + 1]))

        cluster_tabs.children = cluster_tabs_children
        for i, title in enumerate(cluster_titles):
            cluster_tabs.set_title(i, title)

        display(cluster_tabs)
        return cluster_tabs

    def generate_explanation(self):

        explainer = Explainer(self._source_df, self._labels)
        self._explanations = explainer.generate_explanations(coverage_threshold=self._coverage_threshold,
                                                             conciseness_threshold=self._conciseness_threshold,
                                                             separation_threshold=self._separation_threshold,
                                                             p_value=self._p_value)

        return self._explanations
