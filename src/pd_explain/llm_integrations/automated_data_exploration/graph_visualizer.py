import textwrap

import ipycytoscape
import ipywidgets as widgets
import pandas as pd
from ipywidgets import VBox, Tab

from pd_explain.llm_integrations.automated_data_exploration.data_structures import QueryResultObject, QueryTree
from pd_explain.llm_integrations.automated_data_exploration.simple_visualizer import SimpleAutomatedExplorationVisualizer
from pd_explain.llm_integrations.visualization_beautifier import VisualizationBeautifier

class GraphAutomatedExplorationVisualizer(SimpleAutomatedExplorationVisualizer):
    """
    A class to visualize the results of a deep dive analysis performed by an LLM on a DataFrame.
    This class extends the SimpleDeepDiveVisualizer to provide a richer visualization for the query tree
    using ipycytoscape for an interactive graph representation of the queries and their relationships.
    """

    def __init__(self, history: pd.DataFrame, final_report, query_and_results: dict[int, QueryResultObject],
                 visualization_queries: list[int | str], query_tree: QueryTree,
                 source_name: str = "Original DataFrame", beautify_fedex: bool = False,
                 beautify_metainsight: bool = False, beautify_query_tree: bool = False, verbose: bool = False):
        """
        Initialize the GraphAutomatedExplorationVisualizer with the necessary data.

        :param history: A DataFrame containing the history of queries and their results.
        :param final_report: The final report generated by the LLM.
        :param query_and_results: A dictionary mapping query indices to their results.
        :param visualization_queries: A list of query indices that are important for visualization.
        :param query_tree: The query tree structure containing the ancestry of queries.
        :param source_name: The name of the original DataFrame or data source.
        """
        super().__init__(history, final_report, query_and_results,
                         visualization_queries, query_tree, source_name,
                         beautify_fedex=beautify_fedex,
                         beautify_metainsight=beautify_metainsight,
                         beautify_query_tree=beautify_query_tree)
        # Store click handlers for ipycytoscape nodes
        self._node_click_handlers = {}


    def _create_tree_node_data_and_click_handler(self, node_index: int, query_tree_str: dict[int, str],
                                                    parent_index: int = None) -> tuple[dict, callable]:
        """
        Creates the data for a tree node in the query tree visualization.
        Also creates the click handler function for the node.

        :param node_index: The index of the tree node to create.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :param parent_index: The index of the parent node, if any.

        :return: A tuple containing the node data and the click handler function.
        """
        # Check if there are any findings to visualize and if there is an error
        node_row = self.history.iloc[node_index]
        query_description = node_row['query_description'] if 'query_description' in node_row else None
        is_error = node_row['error'] is not None
        fedex_findings_count = len(node_row['fedex_explainer_findings']) if isinstance(
            node_row['fedex_explainer_findings'], list) else 0
        metainsight_findings_count = len(node_row['metainsight_explainer_findings']) if isinstance(
            node_row['metainsight_explainer_findings'], list) else 0
        has_findings = (fedex_findings_count > 0 or metainsight_findings_count > 0)

        if query_description is not None:
            node_label = f"Query {node_index}:\n\n {query_description}"
            if is_error:
                node_label += f"\n\n {query_tree_str.get(node_index, 'Unknown Query')}"
        else:
            # Create the detailed label for the node
            node_label = f"Query {node_index}\n\n" if node_index != 0 else "Original DataFrame\n\n"
            node_label += query_tree_str.get(node_index, "Unknown Query")

        if is_error:
            node_label += "\n\n\n Query execution failed with an error."

        if not is_error:
            if fedex_findings_count > 0:
                node_label += f"\n\n\nFEDEx: {fedex_findings_count}"
            if metainsight_findings_count > 0:
                node_label += f"\n\n\nMetaInsight: {metainsight_findings_count}"


        # Wrap the label text to fit within the node
        node_label = textwrap.fill(node_label, width=50)  # Adjust width as needed

        node_data = {
            'data': {
                'id': str(node_index),
                'name': f"Query {node_index}",  # Main label for the node
                'label': node_label,  # Shorter label for display
                'is_error': str(is_error),
                'has_findings': str(has_findings),
            }
        }

        click_handler_func = self._create_on_button_click_handler(node_index, query_tree_str)
        return node_data, click_handler_func


    def _create_query_tree_tab(self, query_tree_str: dict[int, str], ) -> VBox | Tab:
        """
        Create a tab for the query tree visualization using ipycytoscape.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :return: A VBox containing the CytoscapeWidget for the query tree visualization.
        """

        graph = ipycytoscape.CytoscapeWidget(
            layout={'width': '100%', 'height': '100%', 'border': '1px solid lightgray'},
            # Set initial layout to a tree-like algorithm
            cytoscape_layout={'name': 'dagre', 'rankDir': 'TB', 'spacingFactor': 1.5},  # TB for top-to-bottom
            # Set initial zoom and allow user interaction
            min_zoom=0.1,
            max_zoom=3.0,
            zoom=1.0  # Initial zoom level
        )
        graph_nodes = []
        graph_edges = []
        # The root, the original dataframe, is always at index 0
        curr_node_index = 0
        # Create the tree structure using BFS traversal
        seen_set = set()
        queue = [curr_node_index]
        # No longer need depth_map for ipywidgets layout, but keep for depth calculation

        while len(queue) > 0:
            # Pop the first node from the queue and make sure it has not been seen before
            current_node_index = queue.pop(0)
            if current_node_index in seen_set:
                continue
            seen_set.add(current_node_index)  # Corrected: use current_node_index here
            curr_node = self.query_tree[current_node_index]
            # Add all of the children of the current node to the queue, if they have not been seen before
            for child_index in curr_node.children:
                if child_index not in seen_set:
                    queue.append(child_index)

            # Call the helper method to create the tree node's data and its click handler
            node_data, on_button_click_func = self._create_tree_node_data_and_click_handler(
                current_node_index, query_tree_str, parent_index=curr_node.source
            )

            # Store the click handler for later use by ipycytoscape
            if on_button_click_func:
                self._node_click_handlers[current_node_index] = on_button_click_func

            # Add the node data to the graph nodes list
            graph_nodes.append(node_data)
            if curr_node.source is not None:
                graph_edges.append({
                    'data': {
                        'source': str(curr_node.source),
                        'target': str(current_node_index)
                    }
                })

        # Define ipycytoscape stylesheet for custom appearance
        graph.set_style([
            {
                'selector': 'node',
                'style': {
                    'content': 'data(label)',  # Now uses the more detailed label
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '20px',  # Adjusted font size to fit more text
                    'text-wrap': 'wrap',
                    'text-max-width': '200px',  # Increased max width for text
                    'background-color': '#6c757d',  # Default gray for nodes without findings
                    'color': 'white',
                    'border-width': '1px',
                    'border-color': '#343a40',
                    'width': '300px',  # Increased node width
                    'height': 'label',  # Node height will increase as needed based on content
                    'shape': 'round-rectangle',
                    'padding': '30px'
                }
            },
            {
                'selector': 'node[id = "0"]', # Special case for the original DataFrame node
                'style': {
                    'background-color': '#007bff',  # Blue for original DataFrame
                    'shape': 'diamond',
                }
            },
            {
                'selector': 'node[has_findings = "True"]',
                'style': {
                    'background-color': '#17a2b8',  # Info blue for nodes with findings
                }
            },
            {
                'selector': 'node[is_error = "True"]',
                'style': {
                    'background-color': '#dc3545',  # Danger red for error nodes
                    'border-width': '2px',
                    'border-color': '#a71d2a',
                    'color': 'white'
                }
            },
            {
                'selector': 'edge',
                'style': {
                    'width': 2,
                    'line-color': '#ccc',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier'
                }
            },
            {
                'selector': ':selected',  # Style for selected nodes
                'style': {
                    'border-width': '3px',
                    'border-color': '#ffc107',  # Yellow border when selected
                    'shadow-blur': '10px',
                    'shadow-color': '#ffc107'
                }
            }
        ])

        data = {
            'nodes': graph_nodes,
            'edges': graph_edges
        }
        graph.graph.add_graph_from_json(data)

        # Update on_click_handler to use the stored click functions
        def on_cytoscape_node_click(event):
            node_id = int(event['data']['id'])
            # Retrieve the specific click handler for this node
            click_handler_func = self._node_click_handlers.get(node_id)
            is_error = self.history.iloc[node_id]['error'] is not None
            if click_handler_func and not is_error and node_id != 0:
                # Call the stored function. It expects a button object as its first arg,
                # but we can pass None or an empty dict as it only uses clicked_query_idx, which is
                # passed as a default argument in the function definition.
                click_handler_func(None)

        container_vbox = widgets.VBox(
            layout=widgets.Layout(width='100%', height='100%', padding='10px', overflow='auto'),
        )
        disclaimer_html = widgets.HTML(
            value="<p style='font-size: 12px;'>"
                  "Click on a node to visualize its findings. "
                  "The original DataFrame is shown in blue, queries with findings in teal, queries without findings in gray, "
                  "and queries with errors in red.</p>"
        )
        container_vbox.children = [graph, disclaimer_html]

        graph.on('node', 'click', on_cytoscape_node_click)

        if not self.beautify_query_tree:
            return container_vbox
        else:
            beautifier = VisualizationBeautifier(
                visualization_object=graph,
                data=self.history,
                requester_name='graph_visualizer',
                silent=True,
                visualization_params={
                    'history': self.history,
                    'query_and_results': self.query_and_results,
                    'query_tree': self.query_tree,
                    'query_tree_str': query_tree_str,
                }
            )
            if not self.query_tree_beautify_code:
                print("Generating beautification code for the query tree visualization...")
                beautified_graph, visualization_code = beautifier.do_llm_action()
                if visualization_code is None:
                    visualization_code = "Could not beautify the graph visualization."
                self.visualization_code = visualization_code
                return beautified_graph
            else:
                beautified_graph = beautifier.beautify_from_code(self.visualization_code)
                return beautified_graph
