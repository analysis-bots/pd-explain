import re

import ipywidgets as widgets
import matplotlib.pyplot as plt
from IPython.display import display, HTML
import pandas as pd
import warnings

from pd_explain.llm_integrations.automated_data_exploration.data_structures import QueryResultObject, QueryTree


class AutomatedExplorationVisualizer:
    """
    A class to visualize the results of an automated data exploration analysis performed by an LLM on a DataFrame.
    This class provides a tabbed interface to display the summary report, important queries, and the query tree.
    """

    def __init__(self, history: pd.DataFrame, final_report, query_and_results: dict[int, QueryResultObject],
                 query_tree: QueryTree, log: list[str] = None,
                 source_name: str = "Original DataFrame", beautify_fedex: bool = False,
                 beautify_metainsight: bool = False, beautify_query_tree: bool = False, verbose: bool = False,
                 *args,
                 **kwargs):
        """
        Initialize the SimpleAutomatedExplorationVisualizer with the necessary data.

        :param history: A DataFrame containing the history of queries and their results.
        :param final_report: The final report generated by the LLM.
        :param query_and_results: A dictionary mapping query indices to their results.
        :param referenced_queries: A list of query indices that are important for visualization.
        :param query_tree: The query tree structure containing the ancestry of queries.
        :param log: A list of log messages generated during the analysis.
        :param source_name: The name of the original DataFrame or data source.
        :param beautify_fedex: Whether to beautify the FedEx visualizations using the LLM beautifier.
        :param beautify_metainsight: Whether to beautify the MetaInsight visualizations using the LLM beautifier.
        :param beautify_query_tree: Whether to beautify the query tree visualizations using the LLM beautifier.
        """
        self.history = history
        self.final_report = final_report
        self.referenced_queries = self._find_referenced_queries()
        self.query_and_results = query_and_results
        self.query_tree = query_tree
        self.source_name = source_name
        self.main_tabs = None  # This will hold the main tabs widget
        self.beautify_fedex = beautify_fedex
        self.beautify_metainsight = beautify_metainsight
        self.beautify_query_tree = beautify_query_tree
        self.fedex_beautify_code = None
        self.metainsight_beautify_code = None
        self.query_tree_beautify_code = None
        self.verbose = verbose
        self.log = log

    def _create_query_string(self, query_idx: int) -> str:
        """
        Create a string representation of the query ancestry for a given query index.
        :param query_idx: The index of the query in the query tree.
        :return: A string representation of the query ancestry.
        """
        current_query_node = self.query_tree.get_node(query_idx)
        ancestor_idx = current_query_node.source
        query_ancestry = []
        # Traverse the query tree to find the ancestry of the current query
        while ancestor_idx is not None:
            query_ancestry.append(current_query_node)
            ancestor_node = self.query_tree.get_node(ancestor_idx)
            ancestor_idx = ancestor_node.source if ancestor_node else None
            current_query_node = ancestor_node
        # Reverse to show from root to current query
        query_ancestry.reverse()
        query_string = f"{self.source_name}"
        if query_ancestry:
            query_string += " -> " + " -> ".join(
                [f"{node.query}" for node in query_ancestry if node.query is not None]
            )
        # Replace the placeholder [df] with the source name
        return query_string.replace("[df]", self.source_name)

    def _create_single_query_visualization_content(self, query_idx: int,
                                                   query_tree_str: dict[int, str]) -> widgets.VBox:
        """
        Create a VBox containing visualizations for a single query.
        This is a new helper method to modularize the visualization creation.

        :param query_idx: The index of the query to visualize.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :return: A VBox containing the visualizations for the query.
        """
        query_info = self.query_and_results.get(query_idx, None)
        if query_info is None:
            return widgets.VBox([widgets.HTML(value=f"<p>No results found for query {query_idx}.</p>")])

        query_row = self.history.iloc[query_idx] if query_idx < len(self.history) else None
        if query_row is not None:
            query_description = query_row['query_description'] if 'query_description' in query_row else None
            findings_description = query_row['query_findings'] if 'query_findings' in query_row else None
            # Default to None if the findings description is the placeholder text
            if findings_description is not None and findings_description.startswith("This query requires a summary of its findings"):
                findings_description = None
        else:
            query_description = None
            findings_description = None
        query_string = query_tree_str.get(query_idx, f"Unknown Query {query_idx}")
        title_string = ""
        if query_description is not None:
            title_string += (f"<h2 style='margin-top: 20px; margin-bottom: 10px; align: center;'>"
                             f"Query {query_idx}: {query_description}</h2>")
            if findings_description is not None:
                title_string += f"<h3 style='margin-bottom: 10px;'>Findings: {findings_description}</h3>"
            title_string += f"<p style='margin-bottom: 10px;'>Executed query: {query_string}</p>"
        else:
            title_string += (f"<h2 style='margin-top: 20px; margin-bottom: 10px; align: center;'>"
                             f"Query {query_idx}: {query_string}</h2>")
            if findings_description is not None:
                title_string += f"<h3 style='margin-bottom: 10px;'>Findings: {findings_description}</h3>"

        query_title = widgets.HTML(value=title_string)

        items_for_this_query = [query_title]
        something_visualized = False
        accordion = widgets.Accordion()
        accordion_children = []
        accordion_titles = []

        # Visualize the FedEx and MetaInsight findings if they exist
        if query_info.fedex is not None and len(query_info.fedex) > 0:
            if self.beautify_fedex:
                query_info.fedex._beautify = True
            else:
                query_info.fedex._beautify = False
            fedex_output = widgets.Output(layout=widgets.Layout(width='100%'))
            with fedex_output:
                plt.close('all')  # Close previous plots to prevent overlap
                query_info.fedex.visualize(query_info.fedex._results, beautify_code=self.fedex_beautify_code)
                # If beautify_fedex is True, display will already be called in the visualize method.
                if not self.beautify_fedex:
                    plt.show()
            plt.close('all')  # Close previous plots to prevent overlap
            accordion_children.append(fedex_output)
            accordion_titles.append("FEDEx Visualizations")
            something_visualized = True

        if query_info.metainsight is not None and len(query_info.metainsight) > 0:
            if self.beautify_metainsight:
                query_info.metainsight.beautify = True
            else:
                query_info.metainsight.beautify = False
            meta_output = widgets.Output(layout=widgets.Layout(width='100%'))
            with meta_output:
                plt.close('all')  # Close previous plots
                query_info.metainsight.visualize(beautify_code=self.metainsight_beautify_code)
                # If beautify_metainsight is True, display will already be called in the visualize method.
                if not self.beautify_metainsight:
                    plt.show()
            plt.close('all')  # Close previous plots to prevent overlap
            accordion_children.append(meta_output)
            accordion_titles.append("MetaInsight Visualizations")
            something_visualized = True

        if not something_visualized:
            items_for_this_query.append(
                widgets.HTML(value=f"<p>No visualizations available for this query.</p>")
            )
        else:
            # Create the accordion with the visualizations
            accordion.children = accordion_children
            for i, title in enumerate(accordion_titles):
                accordion.set_title(i, title)
            items_for_this_query.append(accordion)

        query_vbox = widgets.VBox(
            children=items_for_this_query,
            layout=widgets.Layout(
                width='100%',
                overflow_y='visible',  # Let content determine height
                overflow_x='auto',
                border='1px solid #ddd',
                padding='10px'
            )
        )
        return query_vbox

    def _create_referenced_queries_tab(self, query_tree_str: dict[int, str]) -> widgets.VBox:
        """
        Create a tab containing visualizations for the important queries identified by the LLM.
        This tab will have subtabs for each important query, allowing users to visualize the findings from the explainers.
        :param query_tree_str: A dictionary mapping query indices to their string representations.

        :return: A VBox containing the visualizations for the important queries.
        """

        visualization_vbox = widgets.VBox(
            layout=widgets.Layout(
                width='100%',
                height='100%',  # Set the height to 90vh to fill most of the screen
                overflow_y='auto'  # Allow vertical scrolling if content is taller than 90vh
            )
        )
        #  Create the “Main Query Visualizations” tab,
        #  which itself has subtabs for each query.
        visualization_subtabs = widgets.Tab(
            layout=widgets.Layout(
                width='100%',
                height='100%',  # <— let it inherit the parent's 90vh
                overflow_y='auto',  # <— scroll if the content is taller,
            )
        )

        subtabs = []

        if not self.referenced_queries:
            no_viz = widgets.HTML(value="<p>No important queries were identified for visualization.</p>")
            subtabs.append((no_viz, "No Visualizations"))

        else:
            for i, query_idx in enumerate(self.referenced_queries):
                try:
                    query_idx = int(query_idx.strip() if isinstance(query_idx, str) else query_idx)
                except ValueError:
                    continue

                query_vbox = self._create_single_query_visualization_content(
                    query_idx=query_idx,
                    query_tree_str=query_tree_str
                )

                subtabs.append((query_vbox, f"Query {query_idx}"))

        # Now actually assign the children of visualization_subtabs
        visualization_subtabs.children = [content for content, _ in subtabs]
        for i, (_, title) in enumerate(subtabs):
            visualization_subtabs.set_title(i, title)

        # Commented out line includes the disclaimer at the top, but it may not be needed and just take up space.
        # I moved this disclaimer to the bottom of the summary tab instead.
        # visualization_vbox.children = [disclaimer, visualization_subtabs]
        visualization_vbox.children = [visualization_subtabs]
        return visualization_vbox

    def _create_on_button_click_handler(self, node_index, query_tree_str: dict[int, str]) -> callable:
        def on_button_click(b, clicked_query_idx=node_index):
            # Create the content for the new tab using the helper method
            new_tab_visualization_content = self._create_single_query_visualization_content(
                clicked_query_idx,
                query_tree_str=query_tree_str
            )

            # Create a close button for the new tab
            close_button = widgets.Button(
                description="Close Tab",
                button_style='danger',
                layout=widgets.Layout(width='100px', margin='10px auto 25px auto')  # Center the close button
            )

            # Create a VBox to hold the visualization and the close button
            # This ensures the close button is part of the tab's content and scrolls with it
            tab_container_vbox = widgets.VBox([close_button, new_tab_visualization_content])

            # Get current children and titles from the main tabs widget
            # Convert to lists to allow modification
            self._current_main_tab_children = list(self.main_tabs.children)
            self._current_main_tab_titles = [self.main_tabs.get_title(i) for i in
                                             range(len(self.main_tabs.children))]

            # Add the new tab content and title
            self._current_main_tab_children.append(tab_container_vbox)
            new_tab_title = f"Viz: Query {clicked_query_idx}"
            self._current_main_tab_titles.append(new_tab_title)

            # Update the main tabs' children and titles
            self.main_tabs.children = tuple(self._current_main_tab_children)
            for i, title in enumerate(self._current_main_tab_titles):
                self.main_tabs.set_title(i, title)

            # Set the newly added tab as the selected one
            self.main_tabs.selected_index = len(self._current_main_tab_children) - 1

            # Define the click handler for the close button
            def on_close_button_click(cb):
                # Find the index of the tab to close
                # We iterate through the current children to find the exact widget instance
                try:
                    tab_to_close_index = self._current_main_tab_children.index(tab_container_vbox)
                except ValueError:
                    # Tab might have already been removed by another close button or action
                    print("Error: Tab not found for closing.")
                    return

                # Remove the tab content and title from the lists
                del self._current_main_tab_children[tab_to_close_index]
                del self._current_main_tab_titles[tab_to_close_index]

                # Update the main tabs' children and titles
                self.main_tabs.children = tuple(self._current_main_tab_children)
                for i, title in enumerate(self._current_main_tab_titles):
                    self.main_tabs.set_title(i, title)

                # Adjust selected index if the closed tab was the active one
                if self.main_tabs.selected_index == tab_to_close_index:
                    if len(self._current_main_tab_children) > 0:
                        # Select the last remaining tab, or the previous one if available
                        self.main_tabs.selected_index = min(tab_to_close_index,
                                                            len(self._current_main_tab_children) - 1)
                    else:
                        # This case should ideally not be hit as initial tabs are not closable
                        pass
                elif self.main_tabs.selected_index > tab_to_close_index:
                    # If a tab after the closed one was selected, its index shifts left
                    self.main_tabs.selected_index -= 1

            close_button.on_click(on_close_button_click)

        return on_button_click

    def _find_referenced_queries(self) -> list[int]:
        """
        Finds all queries referenced in the final report and returns a list of their indices,
        as well as a list of their text indexes in the final report.

        :return: A tuple containing a list of referenced query indices and a list of their text indexes in the final report.
        """
        # Regex - find all queries in the specified format, i.e., "Query 1", "Query 2", etc.
        # and replace them with <need_link> Query 1 </need_link>, so we can later easily find them and link to them.
        referenced_queries_regex = r"\s*[Qq]uery\s+\d+"
        referenced_queries_iter = re.findall(referenced_queries_regex, self.final_report)
        referenced_queries = set()
        # Take only the last part of the query, which is the index.
        for match in referenced_queries_iter:
            referenced_queries.add(match.split(maxsplit=1)[-1])
        # Convert the set to a list and sort it
        referenced_queries = list(referenced_queries)
        # Annoying case that sometimes happens: referenced queries can be a list of strings that can not be
        # converted to integers, if the LLM gets the format wrong.
        # We will deal with the conversion to integers here, and if it fails, we will try to find the first integer in the string.
        for i, query_idx in enumerate(referenced_queries):
            try:
                # Try to convert the query index to an integer
                referenced_queries[i] = int(query_idx.strip() if isinstance(query_idx, str) else query_idx)
            except ValueError:
                # If it fails, we lower the string, split it by spaces, and try to find the first integer in it.
                parts = query_idx.lower().split()
                for part in parts:
                    try:
                        self.referenced_queries[i] = int(part)
                        break  # If we found a valid integer, break out of the loop
                    except ValueError:
                        continue
                    # If we still can't convert it, we just leave it as is, and let the error handling later on skip it.
        # Sort the referenced queries by their index
        referenced_queries.sort()
        # Return the list of referenced queries and their text indexes
        return referenced_queries

    def _create_summary_tab(self) -> widgets.HTML:
        """
        Create a summary tab that displays the final report generated by the LLM.
        """

        """
        You may want to make the queries referenced in the final report clickable, so that when the user clicks on them,
        it will either open a new tab with the visualizations for that query, make a pop up show, or just send them to the 
        correct referenced queries tab.
        
        DON'T.
        SERIOUSLY, DON'T.
        
        I tried that, for a few days, and have come to the conclusion that is an absolute nightmare to implement, and 
        so I am leaving this warning here for any future developers before they too go down this rabbit hole.
        
        In short:
        - I first tried to replace the text itself with ipywdiget buttons is one way, but those buttons can not simply be 
            thrown inside the HTML widget, because it does not support them. So you need to separate the text into 
            multiple widgets: text before the button, the button itself, and the text after the button.
            However, this will then make the boxes mess everything up, because they automatically put a line break 
            or a space after each widget, and the text will not be aligned properly, and ipywidget does not 
            offer any container that does not have this behavior.
        - I then tried to create elements with an onclick handler instead, using javascript to programmatically click the 
            correct tab (since the Python code runs on the Jupyter backend, and only buttons support an onclick event out of all the ipywidget widgets).
            But, ipywidgets apparently does not actually respond to DOM events, but instead utilizes some
            backend to handle events, so trying to trigger those events using click() does not work. Likewise, trying to simulate other 
            DOM events that should have triggered the click event did not work either, despite (and I checked through the 
            browser debugger) that every DOM element and event was set up correctly.
        - I then tried putting invisible buttons over the text, but trying to get the coordinates of the text 
            to place the buttons over it is impossible and depends on where the text is rendered, which is not
            something under my control at all.
        - Finally, I tried to send events to the backend directly, but from monitoring the network requests 
           in the browser, it seemed completely impossible to do that, because the events are not sent as simple HTTP requests,
           but rather as some kind of websocket messages that are not documented anywhere, and I could not
           figure out how to send them correctly.
           
        So basically, I spent way too much time on this, and it is not worth it.
        The only way I can see this working is by creating a custom widget that extends the HTML widget
        and adds the ability to handle click events on specific parts of the text, or by creating a custom
        HTML element that can handle all of the required logic for the tabs, buttons, and displaying of the 
        visualizations rendered via matplotlib, in a way that is also stable, works on all browsers, and can be 
        saved as a static HTML file without needing to save the matplotlib figures separately.
        But that is a lot of work for the sake of sparing users 2 whole clicks, and I do not think it is worth it.
        """


        if self.final_report is None:
            return widgets.HTML(value="<p>No final report available.</p>")

        formatted_report = self.final_report.replace('\n\n', '</p><p>')
        formatted_report = formatted_report.replace('\n', '<br>')
        # Replace ** with <strong> and ** with </strong> for bold text
        pattern = re.compile(r'\*\*(.*?)\*\*')
        formatted_report = pattern.sub(r'<strong>\1</strong>', formatted_report)

        disclaimer_html = """
        <div style='max-width:800px; line-height:1.5; font-family:Arial,sans-serif; margin-top: 20px;'>
            <hr>
            <p><strong>This report was generated by an LLM, and may contain inaccuracies or errors.</strong></p>
            <p>Please review the findings and visualizations carefully, and use your own judgment to draw conclusions.</p>
            <br>
            <p>For more information about the queries used by the LLM to draw conclusions, see the "Referenced Queries" tab.</p>
        </div>
        """

        return widgets.HTML(
            f"<div class='report-container'>{formatted_report}</div>"
            f"<br>"
            f"{disclaimer_html}"
            f"<br>"
        )

    def _create_log_tab(self) -> widgets.HTML:
        """
        Create a tab that displays the log messages generated during the analysis.
        This tab will show the log messages in a formatted HTML structure with appropriate styling.
        """
        if not self.log:
            return widgets.HTML(value="<p>No log messages available.</p>")

        formatted_log = "<br>".join(self.log)
        formatted_log = formatted_log.replace('\n', '<br>')
        log_html = f"""
        <div style='padding:20px; max-width:100%; line-height:1.5; font-family:Arial,sans-serif;'>
            <p>{formatted_log}</p>
        </div>
        """
        log_tab = widgets.HTML(value=log_html)
        return log_tab

    def visualize_data_exploration(self) -> widgets.Tab:
        """
        Visualize the deep dive analysis in a Jupyter notebook with a tabbed interface.

        :return: A Tab widget containing the visualizations.
        """

        # Turn off warnings for the duration of the visualization, because if beautification is enabled,
        # that tends to raise a lot of warnings. Because LLMs are good at generating code that raises warnings, apparently.
        warnings.filterwarnings("ignore")

        # Use the query tree to create a string representation of each query
        query_tree_str = {idx: self._create_query_string(idx) for idx in self.query_tree.tree.keys()}

        # If the beautify flag is set, we will create beautification code for both FedEx and MetaInsight
        # explainers.
        if self.beautify_fedex and not self.fedex_beautify_code:
            print("Creating beautification code for FEDEx explainer, this may take a while...")
            # Select a result from the history with the most fedex findings.
            result = self.history.loc[
                self.history['fedex_explainer_findings'].apply(
                    lambda x: len(x) if isinstance(x, list) else 0
                ).idxmax()
            ]
            # Create the beautification code for FedEx
            result_idx = result.name
            query_info = self.query_and_results.get(result_idx, None)
            if query_info is not None and query_info.fedex is not None:
                # Set all the flags needed for beautification while getting the code and not visualizing it.
                query_info.fedex._beautify = True
                query_info.fedex._return_beautify_code = True
                query_info.fedex._generalize_beautify_code = True
                query_info.fedex._silent_beautify = not self.verbose
                query_info.fedex._do_not_visualize_beautify = True

                fedex_beautify_code = query_info.fedex.visualize()

                # Reset the flags after getting the beautification code
                query_info.fedex._return_beautify_code = False
                query_info.fedex._beautify = False
                if fedex_beautify_code is not None:
                    self.fedex_beautify_code = fedex_beautify_code
                else:
                    self.fedex_beautify_code = "No beautification code available for FedEx."
            else:
                self.fedex_beautify_code = "No FedEx explainer results available for beautification."

        if self.beautify_metainsight and not self.metainsight_beautify_code:
            # Select a result from the history with the most metainsight findings.
            print("Creating beautification code for MetaInsight explainer, this may take a while...")
            result = self.history.loc[
                self.history['metainsight_explainer_findings'].apply(
                    lambda x: len(x) if isinstance(x, list) else 0
                ).idxmax()
            ]
            # Create the beautification code for MetaInsight
            result_idx = result.name
            query_info = self.query_and_results.get(result_idx, None)
            if query_info is not None and query_info.metainsight is not None:
                # Set all the flags needed for beautification while getting the code and not visualizing it.
                query_info.metainsight.beautify = True
                query_info.metainsight.return_beautify_code = True
                query_info.metainsight.generalize_beautify_code = True
                query_info.metainsight.silent_beautify = not self.verbose
                query_info.metainsight._do_not_visualize_beautify = True

                metainsight_beautify_code = query_info.metainsight.visualize()

                # Reset the flags after getting the beautification code
                query_info.metainsight.return_beautify_code = False
                query_info.metainsight.beautify = False
                query_info.metainsight._do_not_visualize_beautify = False
                if metainsight_beautify_code is not None:
                    self.metainsight_beautify_code = metainsight_beautify_code
                else:
                    self.metainsight_beautify_code = "No beautification code available for MetaInsight."
            else:
                self.metainsight_beautify_code = "No MetaInsight explainer results available for beautification."

        #  Create the main tabs: Summary | Important Queries | Query Tree
        main_tabs = widgets.Tab(
            layout=widgets.Layout(
                width='100%',
                height='90vh',  # <— fix the height of the entire Tab widget to 90% of viewport
                overflow_y='auto'  # <— enable scrolling on the outer Tab if it overflows
            )
        )
        self.main_tabs = main_tabs  # Store the main tabs for later use in the close button handler

        summary_tab = self._create_summary_tab()

        referenced_queries_tab = self._create_referenced_queries_tab(
            query_tree_str
        )

        log_tab = self._create_log_tab()

        # Hook everything into the main_tabs widget
        main_tabs.children = [summary_tab, referenced_queries_tab, log_tab]
        main_tabs.set_title(0, "Summary")
        main_tabs.set_title(1, "Referenced Queries")
        main_tabs.set_title(2, "Log")

        # A complete hack to make the tabs display correctly in Jupyter notebook, so they won't be squished.Add commentMore actions
        display(
            HTML(
                """
                <style>
                /* Make every Tab (jupyter-widgets.widget-tab) a vertical flex container */
                .jupyter-widgets.widget-tab {
                    display: flex !important;
                    flex-direction: column;
                    height: 100%;
                }

                /* Fix the TabBar at the top, allow horizontal scrolling of tab titles */
                .jupyter-widgets.widget-tab > .p-TabBar {
                    flex: 0 0 auto;         /* do not grow or shrink */
                    overflow-x: auto;       /* horizontal scrollbar if too many tabs */
                    white-space: nowrap;    /* keep each title on one line */
                }
                .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab {
                    flex: 0 0 auto;         /* prevent individual titles from shrinking */
                    white-space: nowrap;    /* show full text of each title */
                }

                /* Make the TabPanels area fill remaining space and scroll vertically */
                .jupyter-widgets.widget-tab > .p-TabPanels {
                    flex: 1 1 auto;         /* take up all leftover height */
                    overflow-y: auto;       /* vertical scrollbar for content */
                }
                </style>
                """
            )
        )

        # Restore warnings to default behavior
        warnings.filterwarnings("default")

        return main_tabs
