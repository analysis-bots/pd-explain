from collections import defaultdict
import re
import textwrap

import ipycytoscape
import ipywidgets as widgets
import matplotlib.pyplot as plt
from IPython.display import display, HTML
import pandas as pd
from ipycytoscape import CytoscapeWidget

# Assuming these are available in your environment
from pd_explain.llm_integrations.deep_dive.data_structures import QueryResultObject, QueryTree, tree_node
from pd_explain.llm_integrations.deep_dive.simple_visualizer import SimpleDeepDiveVisualizer


class RichDeepDiveVisualizer(SimpleDeepDiveVisualizer):
    """
    A class to visualize the results of a deep dive analysis performed by an LLM on a DataFrame.
    This class extends the SimpleDeepDiveVisualizer to provide a richer visualization for the query tree
    using ipycytoscape for an interactive graph representation of the queries and their relationships.
    """

    def __init__(self, history: pd.DataFrame, final_report, query_and_results: dict[int, QueryResultObject],
                 visualization_queries: list[int | str], query_tree: QueryTree,
                 source_name: str = "Original DataFrame"):
        """
        Initialize the DeepDiveVisualizer with the necessary data.

        :param history: A DataFrame containing the history of queries and their results.
        :param final_report: The final report generated by the LLM.
        :param query_and_results: A dictionary mapping query indices to their results.
        :param visualization_queries: A list of query indices that are important for visualization.
        :param query_tree: The query tree structure containing the ancestry of queries.
        :param source_name: The name of the original DataFrame or data source.
        """
        super().__init__(history, final_report, query_and_results, visualization_queries, query_tree, source_name)
        self.history = history
        self.final_report = final_report
        self.query_and_results = query_and_results
        self.visualization_queries = visualization_queries
        self.query_tree = query_tree
        self.source_name = source_name
        self.main_tabs = None  # This will hold the main tabs widget
        # Store click handlers for ipycytoscape nodes
        self._node_click_handlers = {}

    def _create_tree_node(self, node_index: int, query_tree_str: dict[int, str],
                          parent_index: int = None) -> tuple[
        widgets.VBox | None, str, callable]:  # Corrected return type hint
        """
        Creates a tree node for the query tree visualization.
        Each tree node is a button that, when clicked, opens a new tab with the visualization of the findings from
        the explainers.
        Each button displays the query string, the findings, and in the case there was an error in the query,
        is painted red and becomes unclickable.

        :param node_index: The index of the tree node to create.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :return: A tuple containing the VBox for the node, the finding lines string, and the click handler function.
        """
        # Create a button for the tree node
        node_query_str = query_tree_str.get(node_index, None)
        # Error handling: if we somehow passed an invalid index, return None
        if node_query_str is None:
            return None, "", lambda b, clicked_query_idx=node_index: print(
                f"Cannot visualize query {clicked_query_idx}: invalid index.")
        node_row = self.history.iloc[node_index] if node_index < len(self.history) else None
        # Error handling for the same case
        if node_row is None:
            return None, "", lambda b, clicked_query_idx=node_index: print(
                f"Cannot visualize query {clicked_query_idx}: no row data.")
        error = node_row['error']

        # Create the text that will go into the visualization for this node.
        fedex_finding_lines = node_row['fedex_explainer_findings']
        metainsight_finding_lines = node_row['metainsight_explainer_findings']
        finding_lines = ""
        query_str = textwrap.fill(node_query_str, width=50).replace('\n', '<br>')
        if node_index != 0:
            finding_lines += f"<strong>Query:</strong> {query_str}"
        if isinstance(fedex_finding_lines, list) and len(fedex_finding_lines) > 0:
            if len(finding_lines) > 0:
                finding_lines += "<br>"
            finding_lines += f"<strong>FedEx Findings:</strong> {len(fedex_finding_lines)}"
        if isinstance(metainsight_finding_lines, list) and len(metainsight_finding_lines) > 0:
            if len(finding_lines) > 0:
                finding_lines += "<br>"
            finding_lines += f"<strong>MetaInsight Findings:</strong> {len(metainsight_finding_lines)}"
        if parent_index is not None:
            if len(finding_lines) > 0:
                finding_lines += "<br>"
            finding_lines += f"<strong>Parent:</strong> {parent_index if parent_index != 0 else 'Original DataFrame'}"
        if len(finding_lines) > 0:
            findings_html = widgets.HTML(
                value=finding_lines if finding_lines else "<p>No findings available for this query.</p>",
            )
        else:
            findings_html = widgets.HTML()

        if node_index != 0 and error is None:
            # If there are findings to visualize
            if len(metainsight_finding_lines) > 0 or len(fedex_finding_lines) > 0:
                button_description = f"Visualize findings for query {node_index}"
                button_disabled = False
            else:
                # If there are no findings to visualize, we still create a button, but it is disabled
                button_description = f"Nothing to visualize for query {node_index}"
                button_disabled = True
        elif node_index == 0:
            button_description = f"Original DataFrame: {node_query_str}"
            button_disabled = True
        else:
            button_description = f"Error computing query {node_index}"
            button_disabled = True

        button_layout = widgets.Layout(width='210px',
                                       height='auto',
                                       white_space='normal',
                                       text_wrap='auto',
                                       justify_self='center',
                                       align_self='center',
                                       )
        if error is not None:
            # If there was an error, create a red button that is unclickable
            button = widgets.Button(
                description=button_description,
                disabled=True,
                button_style='danger',
                layout=button_layout,
            )

            # Define a dummy click handler for error nodes
            def on_button_click(b, clicked_query_idx=node_index):
                print(f"Cannot visualize query {clicked_query_idx}: an error occurred.")
        else:
            # If there was no error, create a clickable button
            button = widgets.Button(
                description=button_description,
                disabled=button_disabled,
                # Disable the button for the original DataFrame (index 0) as it has no findings
                tooltip=f"Click to visualize findings for query {node_index}",
                button_style='info' if node_index != 0 else 'primary',
                layout=button_layout,
            )

            # Define the click handler as a nested function to be returned
            def on_button_click(b, clicked_query_idx=node_index):
                # Create the content for the new tab using the helper method
                new_tab_visualization_content = self._create_single_query_visualization_content(
                    clicked_query_idx,
                    query_tree_str=query_tree_str
                )

                # Create a close button for the new tab
                close_button = widgets.Button(
                    description="Close Tab",
                    button_style='danger',
                    layout=widgets.Layout(width='100px', margin='10px auto 25px auto')  # Center the close button
                )

                # Create a VBox to hold the visualization and the close button
                # This ensures the close button is part of the tab's content and scrolls with it
                tab_container_vbox = widgets.VBox([close_button, new_tab_visualization_content])

                # Get current children and titles from the main tabs widget
                # Convert to lists to allow modification
                self._current_main_tab_children = list(self.main_tabs.children)
                self._current_main_tab_titles = [self.main_tabs.get_title(i) for i in
                                                 range(len(self.main_tabs.children))]

                # Add the new tab content and title
                self._current_main_tab_children.append(tab_container_vbox)
                new_tab_title = f"Viz: Query {clicked_query_idx}"
                self._current_main_tab_titles.append(new_tab_title)

                # Update the main tabs' children and titles
                self.main_tabs.children = tuple(self._current_main_tab_children)
                for i, title in enumerate(self._current_main_tab_titles):
                    self.main_tabs.set_title(i, title)

                # Set the newly added tab as the selected one
                self.main_tabs.selected_index = len(self._current_main_tab_children) - 1

                # Define the click handler for the close button
                def on_close_button_click(cb):
                    # Find the index of the tab to close
                    # We iterate through the current children to find the exact widget instance
                    try:
                        tab_to_close_index = self._current_main_tab_children.index(tab_container_vbox)
                    except ValueError:
                        # Tab might have already been removed by another close button or action
                        print("Error: Tab not found for closing.")
                        return

                    # Remove the tab content and title from the lists
                    del self._current_main_tab_children[tab_to_close_index]
                    del self._current_main_tab_titles[tab_to_close_index]

                    # Update the main tabs' children and titles
                    self.main_tabs.children = tuple(self._current_main_tab_children)
                    for i, title in enumerate(self._current_main_tab_titles):
                        self.main_tabs.set_title(i, title)

                    # Adjust selected index if the closed tab was the active one
                    if self.main_tabs.selected_index == tab_to_close_index:
                        if len(self._current_main_tab_children) > 0:
                            # Select the last remaining tab, or the previous one if available
                            self.main_tabs.selected_index = min(tab_to_close_index,
                                                                len(self._current_main_tab_children) - 1)
                        else:
                            # This case should ideally not be hit as initial tabs are not closable
                            pass
                    elif self.main_tabs.selected_index > tab_to_close_index:
                        # If a tab after the closed one was selected, its index shifts left
                        self.main_tabs.selected_index -= 1

                close_button.on_click(on_close_button_click)

            button.on_click(on_button_click)  # Attach to the ipywidgets button

        # Create a VBox to hold the button and the findings
        tree_node_vbox = widgets.VBox(
            children=[button, findings_html],
            layout=widgets.Layout(
                border='1px solid #ddd',
                padding='10px',
                margin='5px 0',
                align_items='stretch',  # Ensures children expand to full width
                width='100%',  # Important: take full width of parent VBox
            )
        )
        # Return the click handler function along with the VBox and finding lines
        return tree_node_vbox, finding_lines, on_button_click

    def _create_query_tree_tab(self, query_tree_str: dict[int, str], ) -> CytoscapeWidget:
        """
        Create a tab for the query tree visualization using ipycytoscape.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :return: An HBox containing the ipycytoscape graph visualization.
        """

        graph = ipycytoscape.CytoscapeWidget(
            layout={'width': '100%', 'height': '100%', 'border': '1px solid lightgray'},
            # Set initial layout to a tree-like algorithm
            cytoscape_layout={'name': 'dagre', 'rankDir': 'BT', 'spacingFactor': 1.2},  # TB for top-to-bottom
            # Set initial zoom and allow user interaction
            min_zoom=0.1,
            max_zoom=3.0,
            zoom=1.0  # Initial zoom level
        )
        graph_nodes = []
        graph_edges = []
        # The root, the original dataframe, is always at index 0
        curr_node_index = 0
        # Create the tree structure using BFS traversal
        seen_set = set()
        queue = [curr_node_index]
        # No longer need depth_map for ipywidgets layout, but keep for depth calculation

        while len(queue) > 0:
            # Pop the first node from the queue and make sure it has not been seen before
            current_node_index = queue.pop(0)
            if current_node_index in seen_set:
                continue
            seen_set.add(current_node_index)  # Corrected: use current_node_index here
            curr_node = self.query_tree[current_node_index]
            # Add all of the children of the current node to the queue, if they have not been seen before
            for child_index in curr_node.children:
                if child_index not in seen_set:
                    queue.append(child_index)

            # Call _create_tree_node to get the ipywidget VBox and the click handler
            new_node_vbox, finding_lines, on_button_click_func = self._create_tree_node(
                node_index=current_node_index,
                query_tree_str=query_tree_str,
                parent_index=curr_node.source if curr_node.source is not None else None
            )

            # Store the click handler for later use by ipycytoscape
            if on_button_click_func:
                self._node_click_handlers[current_node_index] = on_button_click_func

            # Prepare data for ipycytoscape node
            node_row = self.history.iloc[current_node_index]
            is_error = node_row['error'] is not None
            fedex_findings_count = len(node_row['fedex_explainer_findings']) if isinstance(
                node_row['fedex_explainer_findings'], list) else 0
            metainsight_findings_count = len(node_row['metainsight_explainer_findings']) if isinstance(
                node_row['metainsight_explainer_findings'], list) else 0
            has_findings = (fedex_findings_count > 0 or metainsight_findings_count > 0)

            node_depth = self._measure_depth(curr_node)  # Still useful for potential styling or layout hints

            # NEW: More detailed label for the node
            node_label = f"Query {current_node_index}\n\n" if current_node_index != 0 else "Original DataFrame\n\n"
            node_label += textwrap.fill(query_tree_str.get(current_node_index, "Unknown Query"), width=35)
            if fedex_findings_count > 0:
                node_label += f"\n\nFEDEx: {fedex_findings_count}"
            if metainsight_findings_count > 0:
                node_label += f"\nMetaInsight: {metainsight_findings_count}"
            if is_error:
                node_label += "\n\n Query execution failed with an error."

            graph_nodes.append({
                'data': {
                    'id': str(current_node_index),
                    'name': f"Query {current_node_index}",  # Main label for the node
                    'label': node_label,  # Shorter label for display
                    'full_query_string': query_tree_str.get(current_node_index, "Unknown Query") if current_node_index != 0 else "Original DataFrame: " + self.source_name,
                    'findings_summary': finding_lines,  # Can be used in tooltips
                    'depth': node_depth,
                    'is_error': str(is_error),
                    'has_findings': str(has_findings),
                    'is_original_df': (current_node_index == 0)
                }
            })
            if curr_node.source is not None:
                graph_edges.append({
                    'data': {
                        'source': str(curr_node.source),
                        'target': str(current_node_index)
                    }
                })

        # Define ipycytoscape stylesheet for custom appearance
        # NEW: Reordered selectors for correct precedence
        graph.set_style([
            {
                'selector': 'node',
                'style': {
                    'content': 'data(label)',  # Now uses the more detailed label
                    'text-valign': 'center',
                    'text-halign': 'center',
                    'font-size': '20px',  # Adjusted font size to fit more text
                    'text-wrap': 'wrap',
                    'text-max-width': '200px',  # Increased max width for text
                    'background-color': '#6c757d',  # Default gray for nodes without findings
                    'color': 'white',
                    'border-width': '1px',
                    'border-color': '#343a40',
                    'width': '300px',  # Increased node width
                    'height': '300px',  # Increased node height
                    'shape': 'round-rectangle',
                    'padding': '5px'
                }
            },
            {
                'selector': 'node[id = "0"]', # Special case for the original DataFrame node
                'style': {
                    'background-color': '#007bff',  # Blue for original DataFrame
                    'shape': 'ellipse',
                }
            },
            {
                'selector': 'node[has_findings = "True"]',
                'style': {
                    'background-color': '#17a2b8',  # Info blue for nodes with findings
                }
            },
            {
                'selector': 'node[is_error = "True"]',
                'style': {
                    'background-color': '#dc3545',  # Danger red for error nodes
                    'border-width': '2px',
                    'border-color': '#a71d2a',
                    'color': 'white'
                }
            },
            {
                'selector': 'edge',
                'style': {
                    'width': 2,
                    'line-color': '#ccc',
                    'target-arrow-color': '#ccc',
                    'target-arrow-shape': 'triangle',
                    'curve-style': 'bezier'
                }
            },
            {
                'selector': ':selected',  # Style for selected nodes
                'style': {
                    'border-width': '3px',
                    'border-color': '#ffc107',  # Yellow border when selected
                    'shadow-blur': '10px',
                    'shadow-color': '#ffc107'
                }
            }
        ])

        data = {
            'nodes': graph_nodes,
            'edges': graph_edges
        }
        graph.graph.add_graph_from_json(data)

        # Update on_click_handler to use the stored click functions
        def on_cytoscape_node_click(event):
            node_id = int(event['data']['id'])
            # Retrieve the specific click handler for this node
            click_handler_func = self._node_click_handlers.get(node_id)
            if click_handler_func:
                # Call the stored function. It expects a button object as its first arg,
                # but we can pass None or an empty dict as it only uses clicked_query_idx.
                click_handler_func(None)
            else:
                print(f"No specific click handler found for node {node_id}.")

        graph.on('node', 'click', on_cytoscape_node_click)

        return graph
