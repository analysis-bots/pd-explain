from collections import defaultdict
import re
import textwrap
from typing import Callable

import ipywidgets as widgets
import matplotlib.pyplot as plt
from IPython.display import display, HTML
import pandas as pd

from pd_explain.llm_integrations.deep_dive.data_structures import QueryResultObject, QueryTree, tree_node

class SimpleDeepDiveVisualizer:
    """
    A class to visualize the results of a deep dive analysis performed by an LLM on a DataFrame.
    This class provides a tabbed interface to display the summary report, important queries, and the query tree.
    """
    def __init__(self, history: pd.DataFrame, final_report, query_and_results: dict[int, QueryResultObject],
                            visualization_queries: list[int | str], query_tree: QueryTree, source_name: str = "Original DataFrame"):
        """
        Initialize the DeepDiveVisualizer with the necessary data.

        :param history: A DataFrame containing the history of queries and their results.
        :param final_report: The final report generated by the LLM.
        :param query_and_results: A dictionary mapping query indices to their results.
        :param visualization_queries: A list of query indices that are important for visualization.
        :param query_tree: The query tree structure containing the ancestry of queries.
        :param source_name: The name of the original DataFrame or data source.
        """
        self.history = history
        self.final_report = final_report
        self.query_and_results = query_and_results
        self.visualization_queries = visualization_queries
        self.query_tree = query_tree
        self.source_name = source_name
        self.main_tabs = None  # This will hold the main tabs widget


    def _create_query_string(self, query_idx: int) -> str:
        """
        Create a string representation of the query ancestry for a given query index.
        :param query_idx: The index of the query in the query tree.
        :return: A string representation of the query ancestry.
        """
        current_query_node = self.query_tree.get_node(query_idx)
        ancestor_idx = current_query_node.source
        query_ancestry = []
        # Traverse the query tree to find the ancestry of the current query
        while ancestor_idx is not None:
            query_ancestry.append(current_query_node)
            ancestor_node = self.query_tree.get_node(ancestor_idx)
            ancestor_idx = ancestor_node.source if ancestor_node else None
            current_query_node = ancestor_node
        # Reverse to show from root to current query
        query_ancestry.reverse()
        query_string = f"{self.source_name}"
        if query_ancestry:
            query_string += " -> " + " -> ".join(
                [f"{node.query}" for node in query_ancestry if node.query is not None]
            )
        # Replace the placeholder [df] with the source name
        return query_string.replace("[df]", self.source_name)

    def _create_single_query_visualization_content(self, query_idx: int,
                                                   query_tree_str: dict[int, str]) -> widgets.VBox:
        """
        Create a VBox containing visualizations for a single query.
        This is a new helper method to modularize the visualization creation.

        :param query_idx: The index of the query to visualize.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :return: A VBox containing the visualizations for the query.
        """
        query_info = self.query_and_results.get(query_idx, None)
        if query_info is None:
            return widgets.VBox([widgets.HTML(value=f"<p>No results found for query {query_idx}.</p>")])

        query_string = query_tree_str.get(query_idx, f"Unknown Query {query_idx}")
        query_title = widgets.HTML(value=f"<h2 style='margin-top: 20px; margin-bottom: 10px; align: center;'>"
                                         f"Query {query_idx}: {query_string}</h2>")

        items_for_this_query = [query_title]
        something_visualized = False

        # Visualize the FedEx and MetaInsight findings if they exist
        if query_info.fedex is not None and len(query_info.fedex) > 0:
            fedex_title = widgets.HTML(value="<h3>Statistical Changes Analysis (FEDEx Explainer)</h3>")
            fedex_output = widgets.Output(layout=widgets.Layout(width='100%'))
            with fedex_output:
                plt.close('all')  # Close previous plots to prevent overlap
                query_info.fedex.visualize(query_info.fedex._results)
                plt.show()
            items_for_this_query.append(fedex_title)
            items_for_this_query.append(fedex_output)
            something_visualized = True

        if query_info.metainsight is not None and len(query_info.metainsight) > 0:
            meta_title = widgets.HTML(value="<h3>Pattern Detection (MetaInsight Explainer)</h3>")
            meta_output = widgets.Output(layout=widgets.Layout(width='100%'))
            with meta_output:
                plt.close('all')  # Close previous plots
                query_info.metainsight.visualize()
                plt.show()
            items_for_this_query.append(meta_title)
            items_for_this_query.append(meta_output)
            something_visualized = True

        if not something_visualized:
            items_for_this_query.append(
                widgets.HTML(value=f"<p>No visualizations available for this query.</p>")
            )

        query_vbox = widgets.VBox(
            children=items_for_this_query,
            layout=widgets.Layout(
                width='100%',
                overflow_y='visible',  # Let content determine height
                overflow_x='auto',
                border='1px solid #ddd',
                padding='10px'
            )
        )
        return query_vbox

    def _create_important_visualizations_tab(self, query_tree_str: dict[int, str]) -> widgets.VBox:
        """
        Create a tab containing visualizations for the important queries identified by the LLM.
        This tab will have subtabs for each important query, allowing users to visualize the findings from the explainers.
        :param query_tree_str: A dictionary mapping query indices to their string representations.

        :return: A VBox containing the visualizations for the important queries.
        """

        visualization_vbox = widgets.VBox(
            layout=widgets.Layout(
                width='100%',
                height='100%',  # Set the height to 90vh to fill most of the screen
                overflow_y='auto'  # Allow vertical scrolling if content is taller than 90vh
            )
        )
        disclaimer = widgets.HTML(
            value="<p style='font-weight: bold; padding-bottom: 10px; font-size: 14px;'>"
                  "The queries presented in this tab are the ones deemed most important by the LLM when drawing up the conclusions "
                  "from the analysis. <br>"
                  "As such, these may not truly be the most important queries performed during the analysis."
                  "</p>"
        )
        #  Create the “Main Query Visualizations” tab,
        #  which itself has subtabs for each query.
        visualization_subtabs = widgets.Tab(
            layout=widgets.Layout(
                width='100%',
                height='100%',  # <— let it inherit the parent's 90vh
                overflow_y='auto',  # <— scroll if the content is taller,
            )
        )

        subtabs = []

        if not self.visualization_queries:
            no_viz = widgets.HTML(value="<p>No important queries were identified for visualization.</p>")
            subtabs.append((no_viz, "No Visualizations"))

        else:
            for i, query_idx in enumerate(self.visualization_queries):
                try:
                    query_idx = int(query_idx.strip() if isinstance(query_idx, str) else query_idx)
                except ValueError:
                    continue

                query_vbox = self._create_single_query_visualization_content(
                    query_idx=query_idx,
                    query_tree_str=query_tree_str
                )

                subtabs.append((query_vbox, f"Query {query_idx}"))

        # Now actually assign the children of visualization_subtabs
        visualization_subtabs.children = [content for content, _ in subtabs]
        for i, (_, title) in enumerate(subtabs):
            visualization_subtabs.set_title(i, title)

        visualization_vbox.children = [disclaimer, visualization_subtabs]
        return visualization_vbox

    def _create_on_button_click_handler(self, node_index, query_tree_str: dict[int, str]) -> callable:
        def on_button_click(b, clicked_query_idx=node_index):
            # Create the content for the new tab using the helper method
            new_tab_visualization_content = self._create_single_query_visualization_content(
                clicked_query_idx,
                query_tree_str=query_tree_str
            )

            # Create a close button for the new tab
            close_button = widgets.Button(
                description="Close Tab",
                button_style='danger',
                layout=widgets.Layout(width='100px', margin='10px auto 25px auto')  # Center the close button
            )

            # Create a VBox to hold the visualization and the close button
            # This ensures the close button is part of the tab's content and scrolls with it
            tab_container_vbox = widgets.VBox([close_button, new_tab_visualization_content])

            # Get current children and titles from the main tabs widget
            # Convert to lists to allow modification
            self._current_main_tab_children = list(self.main_tabs.children)
            self._current_main_tab_titles = [self.main_tabs.get_title(i) for i in
                                             range(len(self.main_tabs.children))]

            # Add the new tab content and title
            self._current_main_tab_children.append(tab_container_vbox)
            new_tab_title = f"Viz: Query {clicked_query_idx}"
            self._current_main_tab_titles.append(new_tab_title)

            # Update the main tabs' children and titles
            self.main_tabs.children = tuple(self._current_main_tab_children)
            for i, title in enumerate(self._current_main_tab_titles):
                self.main_tabs.set_title(i, title)

            # Set the newly added tab as the selected one
            self.main_tabs.selected_index = len(self._current_main_tab_children) - 1

            # Define the click handler for the close button
            def on_close_button_click(cb):
                # Find the index of the tab to close
                # We iterate through the current children to find the exact widget instance
                try:
                    tab_to_close_index = self._current_main_tab_children.index(tab_container_vbox)
                except ValueError:
                    # Tab might have already been removed by another close button or action
                    print("Error: Tab not found for closing.")
                    return

                # Remove the tab content and title from the lists
                del self._current_main_tab_children[tab_to_close_index]
                del self._current_main_tab_titles[tab_to_close_index]

                # Update the main tabs' children and titles
                self.main_tabs.children = tuple(self._current_main_tab_children)
                for i, title in enumerate(self._current_main_tab_titles):
                    self.main_tabs.set_title(i, title)

                # Adjust selected index if the closed tab was the active one
                if self.main_tabs.selected_index == tab_to_close_index:
                    if len(self._current_main_tab_children) > 0:
                        # Select the last remaining tab, or the previous one if available
                        self.main_tabs.selected_index = min(tab_to_close_index,
                                                            len(self._current_main_tab_children) - 1)
                    else:
                        # This case should ideally not be hit as initial tabs are not closable
                        pass
                elif self.main_tabs.selected_index > tab_to_close_index:
                    # If a tab after the closed one was selected, its index shifts left
                    self.main_tabs.selected_index -= 1

            close_button.on_click(on_close_button_click)

        return on_button_click

    def _create_tree_node(self, node_index: int, query_tree_str: dict[int, str],
                          parent_index: int = None) -> widgets.VBox | None:
        """
        Creates a tree node for the query tree visualization.
        Each tree node is a button that, when clicked, opens a new tab with the visualization of the findings from
        the explainers.
        Each button displays the query string, the findings, and in the case there was an error in the query,
        is painted red and becomes unclickable.

        :param node_index: The index of the tree node to create.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        """
        # Create a button for the tree node
        node_query_str = query_tree_str.get(node_index, None)
        # Error handling: if we somehow passed an invalid index, return None
        if node_query_str is None:
            return None
        node_row = self.history.iloc[node_index] if node_index < len(self.history) else None
        # Error handling for the same case
        if node_row is None:
            return None
        error = node_row['error']

        # Create the text that will go into the visualization for this node.
        fedex_finding_lines = node_row['fedex_explainer_findings']
        metainsight_finding_lines = node_row['metainsight_explainer_findings']
        finding_lines = ""
        query_str = textwrap.fill(node_query_str, width=50).replace('\n', '<br>')
        if node_index != 0:
            finding_lines += f"<strong>Query:</strong> {query_str}"
        if isinstance(fedex_finding_lines, list) and len(fedex_finding_lines) > 0:
            if len(finding_lines) > 0:
                finding_lines += "<br>"
            finding_lines += f"<strong>FedEx Findings:</strong> {len(fedex_finding_lines)}"
        if isinstance(metainsight_finding_lines, list) and len(metainsight_finding_lines) > 0:
            if len(finding_lines) > 0:
                finding_lines += "<br>"
            finding_lines += f"<strong>MetaInsight Findings:</strong> {len(metainsight_finding_lines)}"
        if parent_index is not None:
            if len(finding_lines) > 0:
                finding_lines += "<br>"
            finding_lines += f"<strong>Parent:</strong> {parent_index if parent_index != 0 else 'Original DataFrame'}"
        if len(finding_lines) > 0:
            findings_html = widgets.HTML(
                value=finding_lines if finding_lines else "<p>No findings available for this query.</p>",
            )
        else:
            findings_html = widgets.HTML()

        if node_index != 0 and error is None:
            # If there are findings to visualize
            if len(metainsight_finding_lines) > 0 or len(fedex_finding_lines) > 0:
                button_description = f"Visualize findings for query {node_index}"
                button_disabled = False
            else:
                # If there are no findings to visualize, we still create a button, but it is disabled
                button_description = f"Nothing to visualize for query {node_index}"
                button_disabled = True
        elif node_index == 0:
            button_description = f"Original DataFrame: {node_query_str}"
            button_disabled = True
        else:
            button_description = f"Error computing query {node_index}"
            button_disabled = True

        button_layout = widgets.Layout(width='210px',
                                       height='auto',
                                       white_space='normal',
                                       text_wrap='auto',
                                       justify_self='center',
                                       align_self='center',
                                       )
        if error is not None:
            # If there was an error, create a red button that is unclickable
            button = widgets.Button(
                description=button_description,
                disabled=True,
                button_style='danger',
                layout=button_layout,
            )
        else:
            # If there was no error, create a clickable button
            button = widgets.Button(
                description=button_description,
                disabled=button_disabled,
                # Disable the button for the original DataFrame (index 0) as it has no findings
                tooltip=f"Click to visualize findings for query {node_index}",
                button_style='info' if node_index != 0 else 'primary',
                layout=button_layout,
            )

            on_button_click = self._create_on_button_click_handler(
                node_index=node_index,
                query_tree_str=query_tree_str
            )
            button.on_click(on_button_click)

        # Create a VBox to hold the button and the findings
        tree_node_vbox = widgets.VBox(
            children=[button, findings_html],
            layout=widgets.Layout(
                border='1px solid #ddd',
                padding='10px',
                margin='5px 0',
                align_items='stretch',  # Ensures children expand to full width
                width='100%',  # Important: take full width of parent VBox
            )
        )
        return tree_node_vbox

    def _measure_depth(self, node: tree_node) -> int:
        """
        Measure the depth of a node in the query tree.
        :param node: The tree node to measure the depth of.
        :return: The depth of the node in the query tree.
        """
        if node.source is None:
            return 0
        parent_node = self.query_tree.get_node(node.source)
        if parent_node is None:
            return 0
        return 1 + self._measure_depth(parent_node)

    def _create_query_tree_tab(self, query_tree_str: dict[int, str],) -> widgets.HBox:
        """
        Create a tab for the query tree visualization.
        :param query_tree_str: A dictionary mapping query indices to their string representations.
        :return: A Tab widget containing the query tree visualization.
        """
        # The root, the original dataframe, is always at index 0
        curr_node_index = 0
        # Create the tree structure using BFS traversal
        seen_set = set()
        queue = [curr_node_index]
        depth_map = defaultdict(list)
        while len(queue) > 0:
            # Pop the first node from the queue and make sure it has not been seen before
            current_node_index = queue.pop(0)
            if current_node_index in seen_set:
                continue
            seen_set.add(curr_node_index)
            curr_node = self.query_tree[current_node_index]
            # Add all of the children of the current node to the queue, if they have not been seen before
            for child_index in curr_node.children:
                if child_index not in seen_set:
                    queue.append(child_index)
            # Create a tree node for the current node
            node_depth = self._measure_depth(curr_node)
            new_node = self._create_tree_node(
                node_index=current_node_index,
                query_tree_str=query_tree_str,
                parent_index=curr_node.source if curr_node.source is not None else None
            )
            # Place the tree node in the appropriate layer based on its depth, and connect an arrow to it
            # from its parent node if it has one.
            if new_node is not None:
                depth_map[node_depth].append(new_node)

        layers = []
        for depth in depth_map.keys():
            title_html = widgets.HTML(
                value=f"<h3 style='text-align: center;'>Depth {depth}</h3>",
                layout=widgets.Layout(
                    width='100%',
                    text_align='center',
                    margin='10px 0'
                )
            )
            # For each depth, add the tree nodes to the appropriate layer
            new_layer = widgets.VBox(
                layout=widgets.Layout(
                    min_width='300px',  # Minimum width for each layer
                    width='auto',  # Let width grow to fit content
                    flex='1 1 0px',  # Allow all columns to have same width if possible
                    align_items='stretch',  # Important: makes child nodes fill column width
                    padding='20px',
                ),
                children=[title_html, *depth_map[depth]]
            )
            layers.append(new_layer)

        query_tree_box = widgets.HBox(
            layout=widgets.Layout(
                width='100%',
                height='100%',
                overflow_y='auto',
                overflow_x='auto',
                overflow='auto',
                display='flex',
                flex_direction='row',
                align_items='flex-start',
                flex_flow='row nowrap',  # Ensure horizontal scroll
                flex_wrap='nowrap'  # ensures horizontal arrangement, and overflow-x handles it
            ),
            children=layers
        )
        return query_tree_box

    def visualize_deep_dive(self) -> widgets.Tab:
        """
        Visualize the deep dive analysis in a Jupyter notebook with a tabbed interface.

        :return: A Tab widget containing the visualizations.
        """

        # Use the query tree to create a string representation of each query
        query_tree_str = {idx: self._create_query_string(idx) for idx in self.query_tree.tree.keys()}

        #  Create the main tabs: Summary | Important Queries | Query Tree
        main_tabs = widgets.Tab(
            layout=widgets.Layout(
                width='100%',
                height='90vh',  # <— fix the height of the entire Tab widget to 90% of viewport
                overflow_y='auto'  # <— enable scrolling on the outer Tab if it overflows
            )
        )
        self.main_tabs = main_tabs  # Store the main tabs for later use in the close button handler

        # Tab 0: Text Summary / HTML
        if self.final_report is None:
            summary_html = "<p>No summary was generated.</p>"
        else:
            formatted_report = self.final_report.replace('\n\n', '</p><p>')
            formatted_report = formatted_report.replace('\n', '<br>')
            # Replace ** with <strong> and ** with </strong> for bold text
            pattern = re.compile(r'\*\*(.*?)\*\*')
            formatted_report = pattern.sub(r'<strong>\1</strong>', formatted_report)
            summary_html = f"""
            <div style='padding:20px; max-width:800px; line-height:1.5; font-family:Arial,sans-serif;'>
                <p>{formatted_report}</p>
                <br>
                <br>
                <p><strong>This report was generated by a LLM, and may contain inaccuracies or errors.</strong></p>
                <p>Please review the findings and visualizations carefully, and use your own judgment to draw conclusions.</p>
                <p>For more information about the queries the LLM deemed the most important when finalizing the report, please refer to the "Important Queries" tab.</p>
                <p>To see the entire query tree and how the queries relate to each other, please refer to the "Query Tree" tab.</p>
            </div>
            """
        summary_tab = widgets.HTML(value=summary_html)

        visualizations_subtabs = self._create_important_visualizations_tab(
            query_tree_str
        )

        # Create a placeholder for Query Tree
        query_tree_tab = self._create_query_tree_tab(query_tree_str)

        # Hook everything into the main_tabs widget
        main_tabs.children = [summary_tab, visualizations_subtabs, query_tree_tab]
        main_tabs.set_title(0, "Summary")
        main_tabs.set_title(1, "Important Queries")
        main_tabs.set_title(2, "Query Tree")

        # A complete hack to make the tabs display correctly in Jupyter notebook, so they won't be squished.Add commentMore actions
        display(
            HTML(
                """
                <style>
                /* Make every Tab (jupyter-widgets.widget-tab) a vertical flex container */
                .jupyter-widgets.widget-tab {
                    display: flex !important;
                    flex-direction: column;
                    height: 100%;
                }

                /* Fix the TabBar at the top, allow horizontal scrolling of tab titles */
                .jupyter-widgets.widget-tab > .p-TabBar {
                    flex: 0 0 auto;         /* do not grow or shrink */
                    overflow-x: auto;       /* horizontal scrollbar if too many tabs */
                    white-space: nowrap;    /* keep each title on one line */
                }
                .jupyter-widgets.widget-tab > .p-TabBar .p-TabBar-tab {
                    flex: 0 0 auto;         /* prevent individual titles from shrinking */
                    white-space: nowrap;    /* show full text of each title */
                }

                /* Make the TabPanels area fill remaining space and scroll vertically */
                .jupyter-widgets.widget-tab > .p-TabPanels {
                    flex: 1 1 auto;         /* take up all leftover height */
                    overflow-y: auto;       /* vertical scrollbar for content */
                }
                </style>
                """
            )
        )

        return main_tabs