from abc import ABC, abstractmethod
import pandas as pd
import re

class LLMIntegrationInterface(ABC):

    @abstractmethod
    def do_llm_action(self) -> pd.Series | None | str:
        """
        Abstract method for carrying out an action using a large language model (LLM).
        Should be implemented by subclasses to provide specific functionality.
        Should utilize a LLM to generate explanations.
        Should return a pandas Series in case multiple explanations are expected or possible, string if only one explanation is expected.
        None if there was an error in the process.
        """
        raise NotImplementedError()


    def do_follow_up_action(self, response: str | pd.Series):
        """
        Perform some action based on the response from the LLM.
        For example, in the context of query recommenders, this could be to use the query generated by the LLM to
        query the DataFrame.
        """
        pass


    def _extract_response(self, response: str, start_delimiter: str, end_delimiter: str = None) -> str | None:
        """
        A universal method to extract the response from the LLM, as long as the response is formatted such that
        it is surrounded by a specific delimiter.
        Specifically, it should be surrounded by the delimiter at the beginning and the end.
        """
        # If the end delimiter is not provided, we will use the start delimiter as the end delimiter.
        if end_delimiter is None:
            end_delimiter = start_delimiter
        # The LLM may have added its reasoning, which can mess with retrieval via regex if it thought about the
        # delimiter. If there is no </think> tag this line does nothing.
        response = response.split("</think>")[-1]
        pattern = rf"(?<={start_delimiter})[\s\S]+?(?={end_delimiter})"
        true_response = re.findall(pattern, response)
        # If the LLM did not follow instructions and did not put the delimiter at the end, we will try to extract
        # the response without it. This may not be as accurate, but it is better than nothing.
        if len(true_response) == 0:
            pattern = rf"(?<={start_delimiter})[\s\S]+?(?={end_delimiter})*"
            true_response = re.findall(pattern, response)
            # If we still have no response, then we return None.
            if len(true_response) == 0:
                return None

        # There should be only one response, at the end of the string (after the LLM finishes its thinking).
        true_response = true_response[-1]
        # Remove the delimiter from the response.
        true_response = true_response.replace(start_delimiter, "").replace(end_delimiter, "")
        return true_response
